########################################################
# KEYBOARD LIBRARY FOR REMOTE-NAO-CONTROL FRAMEWORK
########################################################
#   May 2012, Hessel van der Molen, hmolen.science@gmail.com
#   Dutch Nao Team - http://dutchnaoteam.nl
#
#   Requires:
#   - python
#   - pygame
#   - remote control framework
#   - keyboard

import pygame
import sys
   
keyState = {}
ESCAPEBUTTON = 27

# initialize input controller
def init(inputID):
    pygame.init()
    interface = pygame.display.set_mode([190,115])
    pygame.display.set_caption("keyboardController")
    font = pygame.font.Font(None, 20)
    ID_text1 = font.render("Pygame Keyboard Input",True,[255,255,255])
    ID_text2 = font.render("----------------------------",True,[255,255,255])
    ID_text3 = font.render("Keep window focused to",True,[255,255,255])
    ID_text4 = font.render("recieve keyboard input.",True,[255,255,255])
    ID_text5 = font.render("  Press '" + getQuitCommand() + "' to quit.",True,[255,255,255])
    interface.blit(ID_text1, [10,10])
    interface.blit(ID_text2, [10,30])
    interface.blit(ID_text3, [10,50])
    interface.blit(ID_text4, [10,70])
    interface.blit(ID_text5, [10,90])
    pygame.display.update()

# return name of hardcoded button definition which quits the program 
def getQuitCommand():
    return "Esc" 

# retrieve an event, generated by the input-system  
#
# To protect against overhead, the event-queue is preprocessed:
#   - A 'KEYUP' (or button-release) is only passed, if the button was previously pressed
#   - A 'KEYDOWN' (or button-press) is only passed, if there are no events in the queue
#   - A 'Quit' command is always passed.    
# (This will happen when the robot stalls and a large event-queue is created)
def getAction():
    global keyState
    
    event = None
    # check if there are items in the queue
    if (not emptyQueue()):
        #get event
        event = pollEvent()
        #check if there are multiple items in the queue
        # ifso, validateEventQueue (return None if no valid events are on the queue)
        if (not emptyQueue()):
            event = validateEventQueue(event)
            
    #no items in queue & no legal items in queue
    # --> wait for legal event
    if ((event == None) or (not validateEvent(event, "single"))):
        event = waitForEvent()
    
    # register key-events
    if (hasattr(event, 'key')):
        keyState[event.key] = event.type
        
    # check if 'quit'-command has been pressed, or input window is closed
    if (event.type == pygame.QUIT):
        return "quit"
    elif (event.type == pygame.KEYDOWN or event.type == pygame.KEYUP):
        if (event.key == ESCAPEBUTTON):
            return "quit"
        else:
            #put relevant event-data into a nice tuple (instead of dictionary)
            return (event.type, event.key)
    else:
        # an unknown/undefined event occured
        return None

def quit():
    print "input:quit"
    pygame.quit()
        
        
#multiple items in queue --> only allow 'quit' and keyrelease events!  
def validateEventQueue(event):
    if (validateEvent(event, "queue")):
        return event
    else:
        #validate alle events in queue untill:
        # - a valid event is found
        # - or, no events are left
        while (True):
            event = pollEvent()
            if (event.type == pygame.NOEVENT):
                return None
            if (validateEvent(event, "queue")):
                return event
    
# queue is empty / did not contain a legal event, so wait for new event
def waitForEvent():
    while (True):
        event = pygame.event.wait()
        if (hasattr(event, "type")):
            if (validateEvent(event, "single")):
                return event
    
# validate single event
def validateEvent(event, type):
    global keyState
    
    #validate event from queue
    if (type == "queue"):
        if (hasattr(event, 'key')):
            if (event.key in keyState):
                if ((keyState[event.key] == pygame.KEYDOWN) and (event.type == pygame.KEYUP)):
                    return True
            
                if (event.key == ESCAPEBUTTON):
                    return True
                    
    #validate event when queue is empty
    elif (type == "single"):
        if (hasattr(event, 'key')):
            return True
    
    return False
    
#check next event
def peekEvent():
    event = pygame.event.peek()
    if (hasattr(event, 'type')):
        return event
    else:
        return pygame.event.Event(pygame.NOEVENT, {})
 
#retrieve event from event-queue
def pollEvent():
    event = pygame.event.poll()
    if (hasattr(event, 'type')):
        return event
    else:
        return pygame.event.Event(pygame.NOEVENT, {})
        
#check if queue is empty
#empty queue = 'Event(xx-Unknown {})'
def emptyQueue():
    e = peekEvent()
    n = pygame.event.event_name(e.type)
    return n == "Unknown"
