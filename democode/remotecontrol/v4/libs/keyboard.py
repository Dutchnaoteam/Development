import pygame
import sys

# initialize input controller
def init(inputID):
    pygame.init()
    interface = pygame.display.set_mode([200,95])
    pygame.display.set_caption("keyboardController")
    font = pygame.font.Font(None, 20)
    #ID_text1 = font.render("Pygame Keyboard Input",True,[255,255,255])
    #ID_text2 = font.render("---------------------",True,[255,255,255])
    #ID_text3 = font.render("Press any Key...",True,[255,255,255])
    #ID_text4 = font.render("(Press 'Esc' to quit)",True,[255,255,255])
    #interface.blit(ID_text1, [10,10])
    #interface.blit(ID_text2, [10,30])
    #interface.blit(ID_text3, [10,50])
    #interface.blit(ID_text4, [10,70])
    
    ID_text1 = font.render("Pygame Keyboard Input",True,[255,255,255])
    ID_text2 = font.render("---------------------",True,[255,255,255])
    ID_text3 = font.render("Keep window focused.",True,[255,255,255])
    ID_text4 = font.render("Do not close.",True,[255,255,255])

    interface.blit(ID_text1, [10,10])
    interface.blit(ID_text2, [10,30])
    interface.blit(ID_text3, [10,50])
    interface.blit(ID_text4, [10,70])
    
    pygame.display.update()

# return name of hardcoded button definition which quits the program 
def getQuitCommand():
    return "Esc" 
    
# retrieve an event, generated by the input-system  
#
# To protect against overhead, the event-queue is preprocessed:
#   - A 'KEYUP' (or button-release) is only passed, if the button was previously pressed
#   - A 'KEYDOWN' (or button-press) is only passed, if there are no events in the queue

keyState = {}
EMPTYQUEUE = 32
ESCAPEBUTTON = 27
    
def getAction():
    global keyState
    
    #check for multiple events
    #--> if the processing of the previous function took a while, there could be multiple events on the stack
    #    To prevent a fast execution of all stored events after each other, the queue is preprocessed:
    #       Only events which release some action (KEYUP) and undo a previous action (KEYDOWN) are execute
    
    #process queue
    result = False
    
    #empty queue = 'Event(32-Unknown {})'
    # --> (event.type == 32)

    event = None
    # check if there are items in the queue
    if (pygame.event.peek().type != EMPTYQUEUE):
 
        #get event
        event = pygame.event.poll()    
        
        #check if there are multiple items in the queue
        # ifso, validateEventQueue (return None if no valid events are on the queue)
        if (pygame.event.peek().type != EMPTYQUEUE):
            event = validateEventQueue(event)
           
    #no items in queue & no legal items in queue
    # --> wait for legal event
    if ((event == None) or (not validateEvent(event, "single"))):
        event = waitForEvent()
    
    # register key-events
    if (hasattr(event, 'key')):
        keyState[event.key] = event.type
        
    # check if 'quit'-command has been pressed, or input window is closed
    if (event.type == pygame.QUIT):
        return "quit"
    elif (event.type == pygame.KEYDOWN or event.type == pygame.KEYUP):
        if (event.key == 27): #escape character
            return "quit"
        else:
            #put relevant event-data into a nice tuple (instead of dictionary)
            return (event.type, event.key)
    else:
        # an unknown/undefined event occured
        return None

def quit():
    pygame.quit()
        
        
#multiple items in queue --> only allow 'quit' and keyrelease events!  
def validateEventQueue(event):
    if (validateEvent(event, "queue")):
        return event
    else:
        #validate alle events in queue untill:
        # - a valid event is found
        # - or, no events are left
        while (True):
            event = pygame.event.poll()
            if (event.type == pygame.NOEVENT):
                return None
            if (validateEvent(event, "queue")):
                return event
    
# queue is empty / did not contain a legal event, so wait for new event
def waitForEvent():
    while (True):
        event = pygame.event.wait()        
        if (validateEvent(event, "single")):
            return event    
    
# validate single event
def validateEvent(event, type):
    global keyState
    
    #validate event from queue
    if (type == "queue"):
        if (hasattr(event, 'key')):
            if (event.key in keyState):
                if ((keyState[event.key] == pygame.KEYDOWN) and (event.type == pygame.KEYUP)):
                    return True
            
                if (event.key == ESCAPEBUTTON):
                    return True
                    
    #validate event when queue is empty
    elif (type == "single"):
        if (hasattr(event, 'key')):
            return True
    
    
    return False